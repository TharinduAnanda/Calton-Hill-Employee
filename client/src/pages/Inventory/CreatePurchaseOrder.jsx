import React, { useState, useEffect } from 'react';
import { useNavigate, useParams, Link, useLocation } from 'react-router-dom';
import purchaseOrderService from '../../services/purchaseOrderService';
import { getSuppliers } from '../../services/supplierService';
import productService from '../../services/productService';
import {
  Box,
  Typography,
  TextField,
  Button,
  Grid,
  Paper,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  InputAdornment,
  Divider,
  Breadcrumbs,
  Link as MuiLink,
  Stepper,
  Step,
  StepLabel,
  StepContent,
  Alert,
  Snackbar,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Autocomplete,
  Chip,
  Card,
  CardContent,
  CardHeader,
  Switch,
  FormControlLabel,
  Tooltip,
  styled
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Save as SaveIcon,
  ArrowBack as ArrowBackIcon,
  Email as EmailIcon,
  Home as HomeIcon,
  Inventory as InventoryIcon,
  LocalShipping as ShippingIcon,
  Description as DescriptionIcon,
  ShoppingCart as CartIcon,
  Share as ShareIcon,
  AccountCircle as AccountIcon,
  Search as SearchIcon,
  CheckCircle as CheckIcon
} from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';

// Styled components
const StyledCard = styled(Card)(({ theme }) => ({
  marginBottom: theme.spacing(3),
  borderRadius: '12px',
  boxShadow: '0 4px 20px rgba(0,0,0,0.08)',
  transition: 'transform 0.2s ease, box-shadow 0.2s ease',
  border: '1px solid #eef2f6',
  overflow: 'visible',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: '0 8px 28px rgba(0,0,0,0.12)',
  },
}));

const StyledCardHeader = styled(CardHeader)(({ theme }) => ({
  backgroundColor: '#f9fafc',
  '& .MuiCardHeader-title': {
    display: 'flex',
    alignItems: 'center',
    color: theme.palette.primary.main,
    fontWeight: 600,
    fontSize: '1.1rem',
  },
}));

const StyledTableContainer = styled(TableContainer)(({ theme }) => ({
  borderRadius: '12px',
  boxShadow: '0 2px 8px rgba(0,0,0,0.05)',
  marginTop: theme.spacing(2),
  marginBottom: theme.spacing(3),
}));

const PageHeader = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  marginBottom: theme.spacing(3),
  paddingBottom: theme.spacing(2),
  borderBottom: `1px solid ${theme.palette.divider}`,
}));

const StyledFormField = styled(TextField)(({ theme }) => ({
  marginBottom: theme.spacing(2),
  '& .MuiOutlinedInput-root': {
    '&:hover fieldset': {
      borderColor: theme.palette.primary.main,
    },
    '&.Mui-focused fieldset': {
      borderColor: theme.palette.primary.main,
      boxShadow: `0 0 0 2px ${theme.palette.primary.light}30`,
    },
  },
}));

const FormSectionTitle = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  '& .MuiSvgIcon-root': {
    marginRight: theme.spacing(1),
    color: theme.palette.primary.main,
  },
}));

const TotalSection = styled(Box)(({ theme }) => ({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'flex-end',
  backgroundColor: '#f9fafc',
  padding: theme.spacing(2),
  borderRadius: '8px',
  marginTop: theme.spacing(3),
  border: '1px solid #eef2f6',
}));

const TotalRow = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  width: '100%',
  maxWidth: '300px',
  marginBottom: theme.spacing(1),
}));

const GrandTotal = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  width: '100%',
  maxWidth: '300px',
  marginTop: theme.spacing(1),
  paddingTop: theme.spacing(1),
  borderTop: `1px solid ${theme.palette.divider}`,
  fontWeight: 'bold',
  '& .MuiTypography-root': {
    fontWeight: 'bold',
  }
}));

const ActionButtons = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'flex-end',
  gap: theme.spacing(2),
  marginTop: theme.spacing(3),
  padding: theme.spacing(2),
  borderTop: `1px solid ${theme.palette.divider}`,
}));

const defaultPurchaseOrder = {
  poNumber: '', // Will be auto-generated by the server
  orderDate: new Date().toISOString().substring(0, 10),
  expectedDeliveryDate: null,
  supplier: null,
  items: [],
  subtotal: 0,
  taxRate: 0,
  taxAmount: 0,
  shippingCost: 0,
  totalAmount: 0,
  notes: '',
  status: 'draft',
  sendEmailAfterSave: false
};

const CreatePurchaseOrder = () => {
  const [purchaseOrder, setPurchaseOrder] = useState(defaultPurchaseOrder);
  const [suppliers, setSuppliers] = useState([]);
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(false);
  const [isEditMode, setIsEditMode] = useState(false);
  const [error, setError] = useState(null);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  const [activeStep, setActiveStep] = useState(0);
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [quantity, setQuantity] = useState(1);
  const [unitPrice, setUnitPrice] = useState(0);
  const [emailDialogOpen, setEmailDialogOpen] = useState(false);
  const [recipientEmail, setRecipientEmail] = useState('');
  const [emailLoading, setEmailLoading] = useState(false);
  const [previewDialogOpen, setPreviewDialogOpen] = useState(false);
  const [previewData, setPreviewData] = useState(null);
  
  const navigate = useNavigate();
  const { id } = useParams();
  const location = useLocation();
  
  // Add detailed debugging for location state
  console.log("Location state:", location.state);
  console.log("From low stock:", location.state?.fromLowStock);
  console.log("Low stock item:", location.state?.lowStockItem);
  console.log("Prefill data:", location.state?.prefillData);
  
  const prefillData = location.state?.prefillData;
  const fromLowStock = location.state?.fromLowStock || false;
  const lowStockItem = location.state?.lowStockItem;
  const userRole = location.state?.role || 'owner';
  
  useEffect(() => {
    const fetchInitialData = async () => {
      try {
        setLoading(true);
        
        // Fetch suppliers
        const suppliersData = await getSuppliers();
        const suppliersList = Array.isArray(suppliersData?.data) ? suppliersData.data : [];
        setSuppliers(suppliersList);
        
        // Fetch products
        const productsData = await productService.getAllProducts();
        setProducts(productsData);
        
        // If in edit mode, fetch the purchase order
        if (id) {
          setIsEditMode(true);
          const poData = await purchaseOrderService.getPurchaseOrderById(id);
          console.log("Received PO data:", poData); // Debug log
          
          // Find matching supplier if we have a supplier_id
          let matchedSupplier = null;
          
          if (poData.supplier_id && suppliersList.length > 0) {
            // Try to find the supplier in our list
            matchedSupplier = suppliersList.find(s => 
              s.Supplier_ID === poData.supplier_id || 
              s.supplier_id === poData.supplier_id
            );
          }
          
          // Use provided supplier object if no match found by ID
          if (!matchedSupplier && poData.supplier) {
            matchedSupplier = poData.supplier;
          }
          
          // Check for items array directly from the server response
          console.log("Raw items from server:", poData.items);
          
          // Ensure items array exists and is properly formatted
          let processedItems = [];
          
          if (Array.isArray(poData.items) && poData.items.length > 0) {
            processedItems = poData.items.map(item => {
              console.log("Processing item:", item); // Debug item processing
              // Make sure we extract all possible field names from the server response
              return {
                id: item.id,
                productId: item.productId || item.product_id,
                productName: item.productName || item.product_name || "Unknown Product",
                sku: item.sku || item.SKU || '',
                description: item.description || '',
                quantity: parseInt(item.quantity || 0, 10),
                unitPrice: parseFloat(item.unitPrice || item.unit_price || 0),
                total: parseFloat(item.total || (item.quantity * item.unitPrice) || 0)
              };
            });
          }
          
          console.log("Processed items:", processedItems); // Debug processed items
          
          // Sanitize and prepare all data
          const sanitizedData = {
            ...poData,
            // Make sure we have proper field names
            poNumber: poData.poNumber || poData.po_number || '',
            orderDate: poData.orderDate || poData.order_date || new Date().toISOString().substring(0, 10),
            expectedDeliveryDate: poData.expectedDeliveryDate || poData.expected_delivery_date || null,
            supplier: matchedSupplier,
            // Ensure numeric fields are properly parsed
            subtotal: parseFloat(poData.subtotal || 0),
            taxRate: parseFloat(poData.taxRate || poData.tax_rate || 0),
            taxAmount: parseFloat(poData.taxAmount || poData.tax_amount || 0),
            shippingCost: parseFloat(poData.shippingCost || poData.shipping_cost || 0),
            totalAmount: parseFloat(poData.totalAmount || poData.total_amount || 0),
            notes: poData.notes || '',
            status: poData.status || 'draft',
            // Add the processed items
            items: processedItems
          };
          
          console.log("Final sanitized data with items:", sanitizedData); // Debug log
          setPurchaseOrder(sanitizedData);
          
          // Set recipient email from the supplier if available
          if (matchedSupplier) {
            const supplierEmail = matchedSupplier.Email || matchedSupplier.email;
            if (supplierEmail) {
              setRecipientEmail(supplierEmail);
            }
          }
        }
        // Handle prefilled data from navigation state (e.g., from Low Stock Items)
        else if (prefillData) {
          console.log("Got prefill data:", prefillData);
          
          // Match supplier if it's undefined but we have supplier_id
          let matchedSupplier = prefillData.supplier;
          console.log("Initial supplier from prefillData:", matchedSupplier);
          
          // Look for supplier in the prefillData items
          if (!matchedSupplier && Array.isArray(prefillData.items) && prefillData.items.length > 0) {
            const firstItem = prefillData.items[0];
            
            // First check if the item already has a supplier object
            if (firstItem.supplier) {
              console.log("Found supplier object directly in item:", firstItem.supplier);
              matchedSupplier = firstItem.supplier;
            }
            // Otherwise look for supplier_id
            else {
              const supplierId = firstItem.supplier_id || firstItem.Supplier_ID;
              
              if (supplierId) {
                console.log("Looking for supplier with ID:", supplierId);
                console.log("Available suppliers:", suppliersList);
                
                // Try numeric comparison for more reliable matching
                const numericId = Number(supplierId);
                
                matchedSupplier = suppliersList.find(s => 
                  Number(s.id) === numericId || 
                  Number(s.Supplier_ID) === numericId || 
                  Number(s.supplier_id) === numericId
                );
                
                console.log("Found supplier by ID:", matchedSupplier);
              }
            }
          }
          
          // If we have a lowStockItem from state, also try to match supplier
          if (!matchedSupplier && lowStockItem) {
            // Check if lowStockItem has a supplier object
            if (lowStockItem.supplier) {
              console.log("Found supplier object in lowStockItem:", lowStockItem.supplier);
              matchedSupplier = lowStockItem.supplier;
            }
            else {
              const supplierId = lowStockItem.supplier_id || lowStockItem.Supplier_ID;
              
              if (supplierId) {
                console.log("Looking for supplier from lowStockItem with ID:", supplierId);
                
                // Try numeric comparison
                const numericId = Number(supplierId);
                
                matchedSupplier = suppliersList.find(s => 
                  Number(s.id) === numericId || 
                  Number(s.Supplier_ID) === numericId || 
                  Number(s.supplier_id) === numericId
                );
                
                console.log("Found supplier from lowStockItem:", matchedSupplier);
              }
            }
          }
          
          // Last resort fallback to make sure we have a supplier for testing
          if (!matchedSupplier && suppliersList && suppliersList.length > 0) {
            console.log("Using first supplier as fallback");
            matchedSupplier = suppliersList[0];
          }
          
          // Check if we have a supplier and items in prefill data
          let initialItems = [];
          if (Array.isArray(prefillData.items) && prefillData.items.length > 0) {
            initialItems = prefillData.items.map(item => {
              const qty = parseInt(item.quantity || 0, 10);
              // Ensure we always have a valid number for price
              let price = parseFloat(item.unitPrice || 0) || 1.00; // Default start with provided price or 1.00
              
              // If we have a saved price from database lookup, use that for Wall Plugs (ID 12)
              if (item.productId === 12 && window.foundProductPrice && window.foundProductPrice > 0) {
                console.log(`Using database price for ${item.productName}: $${window.foundProductPrice} instead of $${price}`);
                price = parseFloat(window.foundProductPrice);
              }
              
              // Double check that price is a valid number
              if (isNaN(price) || typeof price !== 'number') {
                console.warn(`Invalid price for ${item.productName}, falling back to default: $1.00`);
                price = 1.00;
              }
              
              const total = qty * price;
              
              console.log(`Processing item ${item.productName}: qty=${qty}, price=${price}, total=${total}`);
              
              return {
                productId: item.productId,
                productName: item.productName,
                sku: item.sku || '',
                description: item.description || '',
                quantity: qty,
                unitPrice: price,
                total: total,
                // Preserve all the additional product details from low stock items if available
                stock_level: item.stock_level,
                reorder_level: item.reorder_level,
                category: item.category,
                supplier_id: item.supplier_id,
                // Include any other fields that might be useful
                original_item: item
              };
            });
            
            console.log("Processed initial items:", initialItems);
            
            // Auto-select the first product in the list if coming from low stock items
            if (fromLowStock && initialItems.length > 0 && productsData && productsData.length > 0) {
              console.log("Auto-selecting first product from prefill data");
              const firstItem = initialItems[0];
              
              // Find the matching product in the products list
              const matchedProduct = productsData.find(product => 
                product.Product_ID == firstItem.productId || 
                product.product_id == firstItem.productId ||
                product._id == firstItem.productId
              );
              
              if (matchedProduct) {
                console.log("Found matching product:", matchedProduct);
                
                // Get price from the product database record, prioritizing cost_price
                let itemPrice = 0;
                
                // First try to use cost_price from the matched product
                const productPrice = matchedProduct.cost_price || matchedProduct.Cost_Price || 
                                   matchedProduct.price || matchedProduct.Price || 0;
                
                if (productPrice > 0) {
                  itemPrice = productPrice;
                  console.log(`Using database price for ${matchedProduct.Name}: $${itemPrice}`);
                  
                  // Save the found price for later use when constructing initial items
                  window.foundProductPrice = itemPrice;
                  
                  // Update the prefilled item price in the table to match the database price
                  if (firstItem.unitPrice !== itemPrice) {
                    console.log(`Updating table item price from $${firstItem.unitPrice} to $${itemPrice}`);
                    
                    // First check if purchaseOrder.items exists and has content
                    if (purchaseOrder && purchaseOrder.items && purchaseOrder.items.length > 0) {
                      try {
                        const updatedItems = [...purchaseOrder.items];
                        updatedItems[0] = {
                          ...updatedItems[0],
                          unitPrice: itemPrice,
                          total: updatedItems[0].quantity * itemPrice
                        };
                        
                        // Update the purchase order with corrected price
                        setPurchaseOrder(prev => ({
                          ...prev,
                          items: updatedItems
                        }));
                      } catch (err) {
                        console.error("Error updating purchase order items:", err);
                        // We'll set the correct price when creating the initial items below
                      }
                    } else {
                      console.log("No existing items array to update - will use correct price in initial items");
                    }
                  }
                } else {
                  // Fall back to the item's price if available
                  itemPrice = parseFloat(firstItem.unitPrice || 0);
                  console.log(`Using item price: $${itemPrice}`);
                }
                
                // Ensure we have a valid price
                if (itemPrice <= 0) {
                  console.log("No valid price found, using default price of $1.00");
                  itemPrice = 1.00;
                }
                
                setSelectedProduct(matchedProduct);
                setQuantity(firstItem.quantity || 1);
                setUnitPrice(itemPrice);
              } else {
                console.log("Could not find matching product in products list");
                // Create a product object from the item data
                const syntheticProduct = {
                  Product_ID: firstItem.productId,
                  Name: firstItem.productName,
                  SKU: firstItem.sku,
                  Price: firstItem.unitPrice > 0 ? firstItem.unitPrice : 1.00
                };
                setSelectedProduct(syntheticProduct);
                setQuantity(firstItem.quantity || 1);
                setUnitPrice(syntheticProduct.Price);
              }
            }
          }
          
          // Calculate totals - do this after ensuring we've applied the correct price to items
          let subtotal = initialItems.reduce((total, item) => 
            total + parseFloat(item.total || 0), 0);
          
          // Add some detailed price logging
          console.log("Final item prices before calculating subtotal:");
          initialItems.forEach(item => {
            console.log(`- ${item.productName}: ${item.quantity} x $${item.unitPrice} = $${item.total}`);
          });
          console.log(`Calculated subtotal: $${subtotal}`);
          
          // Get tax rate and shipping cost from prefill data or use defaults
          const taxRate = prefillData.taxRate !== undefined ? prefillData.taxRate : defaultPurchaseOrder.taxRate;
          const shippingCost = prefillData.shippingCost !== undefined ? prefillData.shippingCost : defaultPurchaseOrder.shippingCost;
          
          // Calculate tax amount and total
          const taxAmount = (subtotal * taxRate) / 100;
          const totalAmount = subtotal + taxAmount + parseFloat(shippingCost);
          
          // Set the purchase order with prefilled data and matched supplier
          setPurchaseOrder({
            ...defaultPurchaseOrder,
            supplier: matchedSupplier, // Use matched supplier instead of prefillData.supplier
            items: initialItems,
            notes: prefillData.notes || '',
            subtotal,
            taxRate,
            taxAmount,
            shippingCost,
            totalAmount,
            // Add information about coming from low stock
            fromLowStock: fromLowStock,
            lowStockItem: lowStockItem
          });
          
          // If supplier is provided, set the recipient email
          if (prefillData.supplier) {
            const supplierEmail = prefillData.supplier.email || prefillData.supplier.Email;
            if (supplierEmail) {
              setRecipientEmail(supplierEmail);
            }
          }
          
          // Check if we have complete data
          const hasCompleteData = prefillData.supplier && initialItems.length > 0;
          
          // Always start at Order Items step (step 0), instead of jumping to the review step
          // (The user specifically requested to always start at the Order Items tab)
          setActiveStep(0);
          
          // Show appropriate notification
          if (hasCompleteData) {
            if (fromLowStock && lowStockItem) {
              setSnackbar({
                open: true, 
                message: `Purchase order pre-filled for low stock item: ${lowStockItem.name}`,
                severity: 'info'
              });
            } else {
              setSnackbar({
                open: true, 
                message: 'Purchase order has been pre-filled from low stock items',
                severity: 'info'
              });
            }
          }
        }
        
      } catch (err) {
        setError('Failed to load initial data. Please try again.');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchInitialData();
  }, [id, prefillData]);

  // Calculate totals whenever items, tax rate, or shipping cost changes
  useEffect(() => {
    // First ensure all items have proper totals
    const updatedItems = purchaseOrder.items.map(item => {
      const qty = parseInt(item.quantity || 0, 10);
      const price = parseFloat(item.unitPrice || 0);
      const total = qty * price;
      return {
        ...item,
        quantity: qty,
        unitPrice: price,
        total: total
      };
    });
    
    // Calculate totals but don't trigger a state update that would cause an infinite loop
    let needsUpdate = false;
    let newState = {...purchaseOrder};
    
    // Calculate subtotal
    const subtotal = updatedItems.reduce((total, item) => 
      total + parseFloat(item.total || 0), 0);
    
    if (subtotal !== purchaseOrder.subtotal) {
      newState.subtotal = subtotal;
      needsUpdate = true;
    }
    
    // Calculate tax amount
    const taxRate = parseFloat(purchaseOrder.taxRate || 0);
    const taxAmount = (subtotal * taxRate) / 100;
    
    if (taxAmount !== purchaseOrder.taxAmount) {
      newState.taxAmount = taxAmount;
      needsUpdate = true;
    }
    
    // Calculate total amount
    const shippingCost = parseFloat(purchaseOrder.shippingCost || 0);
    const totalAmount = subtotal + taxAmount + shippingCost;
    
    if (totalAmount !== purchaseOrder.totalAmount) {
      newState.totalAmount = totalAmount;
      needsUpdate = true;
    }
    
    // Check if items changed their totals
    if (JSON.stringify(updatedItems) !== JSON.stringify(purchaseOrder.items)) {
      newState.items = updatedItems;
      needsUpdate = true;
    }
    
    // Only update state if something changed to prevent infinite loops
    if (needsUpdate) {
      setPurchaseOrder(newState);
    }
  }, [purchaseOrder.items, purchaseOrder.taxRate, purchaseOrder.shippingCost]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    
    // Perform real-time validation based on field
    if (name === 'taxRate' && (isNaN(value) || parseFloat(value) < 0)) {
      setError('Tax rate cannot be negative');
    } else if (name === 'shippingCost' && (isNaN(value) || parseFloat(value) < 0)) {
      setError('Shipping cost cannot be negative');
    } else {
      // Clear error if the field is now valid
      if (error && 
         ((name === 'taxRate' && !isNaN(value) && parseFloat(value) >= 0) ||
          (name === 'shippingCost' && !isNaN(value) && parseFloat(value) >= 0))) {
        setError(null);
      }
    }
    
    setPurchaseOrder({
      ...purchaseOrder,
      [name]: name === 'taxRate' || name === 'shippingCost' ? parseFloat(value) || 0 : value
    });
  };

  const handleSupplierChange = (event, newSupplier) => {
    // Clear supplier-related errors when a supplier is selected
    if (newSupplier && error && error.includes('supplier')) {
      setError(null);
    } else if (!newSupplier && purchaseOrder.sendEmailAfterSave) {
      // If supplier is cleared but email sending is enabled, show warning
      setError('A supplier is required to send the purchase order via email');
    }
    
    setPurchaseOrder({
      ...purchaseOrder,
      supplier: newSupplier,
      supplier_id: newSupplier ? (newSupplier.Supplier_ID || newSupplier.id) : null
    });
    
    if (newSupplier && newSupplier.Email) {
      setRecipientEmail(newSupplier.Email);
    } else if (newSupplier && newSupplier.email) {
      setRecipientEmail(newSupplier.email);
    } else {
      setRecipientEmail('');
      
      // If email sending is enabled but supplier has no email, show warning
      if (newSupplier && purchaseOrder.sendEmailAfterSave) {
        setSnackbar({
          open: true,
          message: 'Selected supplier does not have an email address',
          severity: 'warning'
        });
      }
    }
  };

  const handleProductSelect = (event, product) => {
    setSelectedProduct(product);
    
    // Prioritize cost_price first as specified by user requirements
    const productPrice = product?.cost_price || product?.Cost_Price || product?.price || product?.Price || 0;
    console.log(`Selected product ${product?.Name || product?.name} with price fields:`, {
      cost_price: product?.cost_price,
      Cost_Price: product?.Cost_Price,
      price: product?.price,
      Price: product?.Price,
      selected: productPrice
    });
    
    // Parse the product price to ensure it's a valid number
    const parsedPrice = parseFloat(productPrice);
    
    // Only set price if it's valid and > 0
    if (!isNaN(parsedPrice) && parsedPrice > 0) {
      setUnitPrice(parsedPrice);
      console.log(`Set unit price to $${parsedPrice} from product data`);
    } else {
      setUnitPrice(1.00);
      console.log("No valid price found, defaulting to $1.00");
    }
  };

  const handleAddItem = () => {
    // Validate product selection
    if (!selectedProduct) {
      setError('Please select a product to add');
      return;
    }
    
    // Validate quantity
    if (!quantity || quantity <= 0) {
      setError('Please enter a valid quantity (greater than zero)');
      return;
    }
    
    // Parse values first to ensure they're numbers
    const parsedQuantity = parseInt(quantity, 10);
    const parsedUnitPrice = parseFloat(unitPrice);
    
    // Validate unit price after parsing
    if (isNaN(parsedUnitPrice) || parsedUnitPrice < 0) {
      setError('Please enter a valid unit price');
      return;
    }
    
    console.log(`Adding item with unit price: $${parsedUnitPrice} (original input: ${unitPrice})`);
    const calculatedTotal = parsedQuantity * parsedUnitPrice;
    
    // Check if product already exists in the order
    const existingItemIndex = purchaseOrder.items.findIndex(
      item => (item.productId === (selectedProduct.Product_ID || selectedProduct._id))
    );
    
    if (existingItemIndex !== -1) {
      // Ask user if they want to update the existing item
      if (window.confirm('This product is already in the order. Do you want to update the quantity?')) {
        const updatedItems = [...purchaseOrder.items];
        
        // Update the existing item with new quantity and recalculate total
        const existingItem = updatedItems[existingItemIndex];
        existingItem.quantity = parseInt(existingItem.quantity) + parsedQuantity;
        existingItem.total = existingItem.quantity * existingItem.unitPrice;
        
        setPurchaseOrder({
          ...purchaseOrder,
          items: updatedItems
        });
      }
    } else {
      // Create a new item
      const newItem = {
        product: selectedProduct,
        productId: selectedProduct.Product_ID || selectedProduct._id,
        productName: selectedProduct.Name || selectedProduct.name,
        sku: selectedProduct.SKU || selectedProduct.sku,
        quantity: parsedQuantity,
        unitPrice: parsedUnitPrice,
        total: calculatedTotal
      };
      
      setPurchaseOrder({
        ...purchaseOrder,
        items: [...purchaseOrder.items, newItem]
      });
    }
    
    // Show success message
    setSnackbar({
      open: true,
      message: 'Item added successfully',
      severity: 'success'
    });
    
    // Reset selection fields
    setSelectedProduct(null);
    setQuantity(1);
    setUnitPrice(0);
    setError(null);
  };

  const handleRemoveItem = (index) => {
    const updatedItems = [...purchaseOrder.items];
    updatedItems.splice(index, 1);
    
    setPurchaseOrder({
      ...purchaseOrder,
      items: updatedItems
    });
  };

  const handleDateChange = (date, fieldName) => {
    // Validate dates
    if (fieldName === 'expectedDeliveryDate' && date) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      if (date < today) {
        setError('Expected delivery date cannot be in the past');
        return;
      } else {
        // Clear the error if it was related to the delivery date
        if (error && error.includes('delivery date')) {
          setError(null);
        }
      }
    } else if (fieldName === 'orderDate' && !date) {
      setError('Order date is required');
      return;
    } else if (error && error.includes('date') && ((fieldName === 'orderDate' && date) || fieldName !== 'orderDate')) {
      // Clear date-related errors when valid dates are selected
      setError(null);
    }
    
    setPurchaseOrder({
      ...purchaseOrder,
      [fieldName]: date ? date.toISOString().substring(0, 10) : null
    });
  };

  const handleNext = () => {
    // Validate the current step before proceeding
    if (!validateCurrentStep()) {
      return;
    }
    
    setActiveStep((prevActiveStep) => prevActiveStep + 1);
  };

  // Validate the current step based on step index
  const validateCurrentStep = () => {
    let isValid = true;
    let errorMessage = '';
    
    switch (activeStep) {
      case 0: // Order Items step
        if (!Array.isArray(purchaseOrder.items) || purchaseOrder.items.length === 0) {
          isValid = false;
          errorMessage = 'Please add at least one item to the purchase order';
        }
        break;
        
      case 1: // Order Details step
        // Status is the only required field in Order Details
        if (!purchaseOrder.status) {
          isValid = false;
          errorMessage = 'Please select an order status';
        }
        break;
        
      case 2: // Supplier Information step
        if (!purchaseOrder.supplier) {
          isValid = false;
          errorMessage = 'Please select a supplier';
        } else if (!purchaseOrder.orderDate) {
          isValid = false;
          errorMessage = 'Please select an order date';
        }
        break;
        
      default:
        break;
    }
    
    if (!isValid) {
      // Show error message as a toast notification
      setSnackbar({
        open: true,
        message: errorMessage,
        severity: 'error'
      });
    }
    
    return isValid;
  };

  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };

  const handleSendEmailToggle = (event) => {
    setPurchaseOrder({
      ...purchaseOrder,
      sendEmailAfterSave: event.target.checked
    });
  };

  const validatePurchaseOrder = () => {
    // Initialize an array to collect all validation errors
    const errors = [];

    // Supplier validation
    if (!purchaseOrder.supplier) {
      errors.push('Please select a supplier');
    }

    // Date validations
    if (!purchaseOrder.orderDate) {
      errors.push('Order date is required');
    }

    // Expected delivery date validation - should be today or in the future
    if (purchaseOrder.expectedDeliveryDate) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const deliveryDate = new Date(purchaseOrder.expectedDeliveryDate);
      
      if (deliveryDate < today) {
        errors.push('Expected delivery date cannot be in the past');
      }
    }

    // Items validation
    if (!Array.isArray(purchaseOrder.items) || purchaseOrder.items.length === 0) {
      errors.push('Please add at least one item to the purchase order');
    } else {
      // Validate each item
      purchaseOrder.items.forEach((item, index) => {
        if (!item.productId) {
          errors.push(`Item #${index + 1}: Product is required`);
        }
        
        if (!item.quantity || item.quantity <= 0) {
          errors.push(`Item #${index + 1}: Quantity must be greater than zero`);
        }
        
        if (item.unitPrice === undefined || item.unitPrice === null || item.unitPrice < 0) {
          errors.push(`Item #${index + 1}: Unit price must be a valid amount`);
        }
      });
    }

    // Tax Rate validation
    if (purchaseOrder.taxRate < 0) {
      errors.push('Tax rate cannot be negative');
    }

    // Shipping cost validation
    if (purchaseOrder.shippingCost < 0) {
      errors.push('Shipping cost cannot be negative');
    }

    // Total amount validation
    if (purchaseOrder.totalAmount <= 0 && purchaseOrder.items.length > 0) {
      errors.push('Total amount must be greater than zero');
    }

    // Email validation if sending email
    if (purchaseOrder.sendEmailAfterSave && (!purchaseOrder.supplier || !recipientEmail)) {
      errors.push('Supplier must have a valid email address to send the purchase order');
    }

    // If there are any errors, set the first one as the main error message
    // and show a toast notification
    if (errors.length > 0) {
      setError(errors[0]);
      
      // Show toast notification
      setSnackbar({
        open: true,
        message: `Please fix the following: ${errors[0]}`,
        severity: 'error'
      });
      
      // Log more detailed errors if there are multiple
      if (errors.length > 1) {
        console.error('Validation errors:', errors);
      }
      return false;
    }
    
    // Clear any previous error
    setError(null);
    return true;
  };

  const handlePreview = async () => {
    if (!validatePurchaseOrder()) return;
    
    try {
      setLoading(true);
      
      // Generate a real PO number from the server
      const generatedPoNumber = await purchaseOrderService.generatePONumber();
      
      setPreviewData({
        ...purchaseOrder,
        poNumber: generatedPoNumber, // Use the actual generated PO number
        createdAt: new Date().toISOString()
      });
      
      setPreviewDialogOpen(true);
    } catch (error) {
      console.error('Error generating PO number:', error);
      setError('Failed to generate PO number. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async (status = 'draft') => {
    setPreviewDialogOpen(false);
    
    if (!validatePurchaseOrder()) return;
    
    try {
      setLoading(true);
      
      // Update status if provided and use the PO number from preview data
      const updatedOrder = {
        ...purchaseOrder,
        poNumber: previewData?.poNumber, // Use the generated PO number from the preview
        status: status || purchaseOrder.status
      };
      
      let savedOrder;
      
      if (isEditMode) {
        savedOrder = await purchaseOrderService.updatePurchaseOrder(id, updatedOrder);
      } else {
        savedOrder = await purchaseOrderService.createPurchaseOrder(updatedOrder);
      }
      
      // Send email if requested
      if (updatedOrder.sendEmailAfterSave && savedOrder.supplier && savedOrder.supplier.email) {
        try {
          await purchaseOrderService.sendPurchaseOrderEmail(savedOrder.id || id, {
            recipientEmail: updatedOrder.supplier.email,
            subject: `Purchase Order #${savedOrder.poNumber}`,
            message: `Please find attached purchase order #${savedOrder.poNumber}.`
          });
          
          setSnackbar({
            open: true,
            message: 'Purchase order saved and email sent successfully',
            severity: 'success'
          });
        } catch (emailErr) {
          console.error('Error sending email:', emailErr);
          
          setSnackbar({
            open: true,
            message: 'Purchase order saved but email could not be sent',
            severity: 'warning'
          });
        }
      } else {
        setSnackbar({
          open: true,
          message: 'Purchase order saved successfully',
          severity: 'success'
        });
      }
      
      // Redirect to purchase orders list with role preserved
      setTimeout(() => {
        navigate('/owner/inventory/purchase-orders', { state: { role: userRole } });
      }, 1500);
      
    } catch (err) {
      setError('Failed to save purchase order. Please try again.');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  const handleClosePreview = () => {
    setPreviewDialogOpen(false);
  };

  const handleOpenEmailDialog = () => {
    if (!purchaseOrder.supplier) {
      setError('Please select a supplier before sending email');
      return;
    }
    setEmailDialogOpen(true);
  };

  const handleCloseEmailDialog = () => {
    setEmailDialogOpen(false);
  };

  const handleSendEmail = async () => {
    // Validate purchase order first
    if (!validatePurchaseOrder()) return;
    
    // Validate email address
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!recipientEmail || !emailRegex.test(recipientEmail)) {
      setError('Please enter a valid email address');
      return;
    }
    
    try {
      setEmailLoading(true);
      
      // First save the purchase order if in create mode or if there are unsaved changes
      let orderToEmail = purchaseOrder;
      
      if (!isEditMode || purchaseOrder.status === 'draft') {
        // Update status to 'pending' when sending
        const updatedOrder = {
          ...purchaseOrder,
          status: 'pending'
        };
        
        if (isEditMode) {
          orderToEmail = await purchaseOrderService.updatePurchaseOrder(id, updatedOrder);
        } else {
          orderToEmail = await purchaseOrderService.createPurchaseOrder(updatedOrder);
        }
      }
      
      // Now send the email
      await purchaseOrderService.sendPurchaseOrderEmail(orderToEmail.id || id, {
        recipientEmail,
        subject: `Purchase Order #${orderToEmail.poNumber}`,
        message: `Please find attached purchase order #${orderToEmail.poNumber}.`
      });
      
      setSnackbar({
        open: true,
        message: 'Purchase order email sent successfully',
        severity: 'success'
      });
      
      // Update status to 'sent' in local state
      setPurchaseOrder({
        ...orderToEmail,
        status: 'sent'
      });
      
      // Close the dialog and redirect to the list
      handleCloseEmailDialog();
      setTimeout(() => {
        navigate('/owner/inventory/purchase-orders', { state: { role: userRole } });
      }, 1500);
      
    } catch (err) {
      setError('Failed to send email. Please try again.');
      console.error(err);
    } finally {
      setEmailLoading(false);
    }
  };

  // Reorder the steps
  const steps = [
    {
      label: 'Order Items',
      content: (
        <StyledCard>
          <StyledCardHeader 
            title={
              <FormSectionTitle>
                <CartIcon />
                Order Items
              </FormSectionTitle>
            }
          />
          <CardContent>
            {/* Product Selection Form */}
            <Grid container spacing={2} alignItems="flex-end">
              <Grid item xs={12} md={5}>
                <Autocomplete
                  options={products}
                  getOptionLabel={(option) => `${option.Name || option.name} (${option.SKU || option.sku || 'No SKU'})`}
                  isOptionEqualToValue={(option, value) => 
                    option.Product_ID === value.Product_ID || 
                    option._id === value._id
                  }
                  value={selectedProduct}
                  onChange={handleProductSelect}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Select Product"
                      variant="outlined"
                      placeholder="Search products..."
                      fullWidth
                    />
                  )}
                  renderOption={(props, option) => (
                    <li {...props}>
                      <Box sx={{ display: 'flex', flexDirection: 'column' }}>
                        <Typography variant="body1">{option.Name || option.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          SKU: {option.SKU || option.sku || 'No SKU'} | Price: ${option.Price || option.price || option.cost_price || '0.00'}
                        </Typography>
                      </Box>
                    </li>
                  )}
                />
              </Grid>
              
              <Grid item xs={12} md={2}>
                <TextField
                  label="Quantity"
                  type="number"
                  value={quantity}
                  onChange={(e) => setQuantity(e.target.value)}
                  fullWidth
                  variant="outlined"
                  InputProps={{ inputProps: { min: 1 } }}
                />
              </Grid>
              
              <Grid item xs={12} md={3}>
                <TextField
                  label="Unit Price"
                  type="number"
                  value={unitPrice}
                  onChange={(e) => setUnitPrice(e.target.value)}
                  fullWidth
                  variant="outlined"
                  InputProps={{
                    startAdornment: <InputAdornment position="start">$</InputAdornment>,
                    inputProps: { min: 0, step: 0.01 }
                  }}
                />
              </Grid>
              
              <Grid item xs={12} md={2}>
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleAddItem}
                  fullWidth
                  startIcon={<AddIcon />}
                  disabled={!selectedProduct}
                >
                  Add
                </Button>
              </Grid>
            </Grid>
            
            {/* Items Table */}
            <StyledTableContainer>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Product</TableCell>
                    <TableCell>SKU</TableCell>
                    <TableCell align="right">Quantity</TableCell>
                    <TableCell align="right">Unit Price</TableCell>
                    <TableCell align="right">Total</TableCell>
                    <TableCell align="center">Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {Array.isArray(purchaseOrder.items) && purchaseOrder.items.length > 0 ? (
                    purchaseOrder.items.map((item, index) => (
                      <TableRow key={index}>
                        <TableCell>{item.productName || "Unknown Product"}</TableCell>
                        <TableCell>{item.sku || "-"}</TableCell>
                        <TableCell align="right">{item.quantity || 0}</TableCell>
                        <TableCell align="right">${parseFloat(item.unitPrice || 0).toFixed(2)}</TableCell>
                        <TableCell align="right">${parseFloat(item.total || 0).toFixed(2)}</TableCell>
                        <TableCell align="center">
                          <IconButton 
                            color="error"
                            onClick={() => handleRemoveItem(index)}
                            size="small"
                          >
                            <DeleteIcon />
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    ))
                  ) : (
                    <TableRow>
                      <TableCell colSpan={6} align="center">
                        No items added yet. Select products above to add to this purchase order.
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </StyledTableContainer>
            
            {/* Totals Section */}
            {Array.isArray(purchaseOrder.items) && purchaseOrder.items.length > 0 && (
              <TotalSection>
                <TotalRow>
                  <Typography variant="body1">Subtotal:</Typography>
                  <Typography variant="body1">${parseFloat(purchaseOrder.subtotal || 0).toFixed(2)}</Typography>
                </TotalRow>
                
                <TotalRow>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Typography variant="body1" sx={{ mr: 1 }}>Tax Rate:</Typography>
                    <TextField
                      size="small"
                      type="number"
                      name="taxRate"
                      value={purchaseOrder.taxRate}
                      onChange={handleChange}
                      variant="outlined"
                      sx={{ width: '80px' }}
                      InputProps={{
                        endAdornment: <InputAdornment position="end">%</InputAdornment>,
                        inputProps: { min: 0, step: 0.1 }
                      }}
                    />
                  </Box>
                  <Typography variant="body1">${parseFloat(purchaseOrder.taxAmount || 0).toFixed(2)}</Typography>
                </TotalRow>
                
                <TotalRow>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <Typography variant="body1" sx={{ mr: 1 }}>Shipping:</Typography>
                    <TextField
                      size="small"
                      type="number"
                      name="shippingCost"
                      value={purchaseOrder.shippingCost}
                      onChange={handleChange}
                      variant="outlined"
                      sx={{ width: '100px' }}
                      InputProps={{
                        startAdornment: <InputAdornment position="start">$</InputAdornment>,
                        inputProps: { min: 0, step: 0.01 }
                      }}
                    />
                  </Box>
                  <Typography variant="body1">${parseFloat(purchaseOrder.shippingCost || 0).toFixed(2)}</Typography>
                </TotalRow>
                
                <GrandTotal>
                  <Typography variant="h6">Grand Total:</Typography>
                  <Typography variant="h6" color="primary">${parseFloat(purchaseOrder.totalAmount || 0).toFixed(2)}</Typography>
                </GrandTotal>
              </TotalSection>
            )}
          </CardContent>
        </StyledCard>
      )
    },
    {
      label: 'Order Details',
      content: (
        <StyledCard>
          <StyledCardHeader 
            title={
              <FormSectionTitle>
                <DescriptionIcon />
                Order Details
              </FormSectionTitle>
            }
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12}>
                <StyledFormField
                  label="Notes"
                  name="notes"
                  value={purchaseOrder.notes}
                  onChange={handleChange}
                  fullWidth
                  multiline
                  rows={4}
                  variant="outlined"
                  placeholder="Enter any special instructions, delivery notes, or payment terms..."
                />
              </Grid>
              
              <Grid item xs={12}>
                <FormControl component="fieldset" variant="standard">
                  <FormControlLabel
                    control={
                      <Switch 
                        checked={purchaseOrder.sendEmailAfterSave} 
                        onChange={handleSendEmailToggle} 
                        name="sendEmailAfterSave"
                      />
                    }
                    label="Send email to supplier after saving"
                  />
                </FormControl>
              </Grid>
              
              <Grid item xs={12}>
                <FormControl fullWidth variant="outlined">
                  <InputLabel>Status</InputLabel>
                  <Select
                    name="status"
                    value={purchaseOrder.status || 'draft'}
                    onChange={handleChange}
                    label="Status"
                  >
                    <MenuItem value="draft">Draft</MenuItem>
                    <MenuItem value="pending">Pending</MenuItem>
                    <MenuItem value="sent">Sent</MenuItem>
                    <MenuItem value="confirmed">Confirmed</MenuItem>
                    <MenuItem value="canceled">Canceled</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </CardContent>
        </StyledCard>
      )
    },
    {
      label: 'Supplier Information',
      content: (
        <StyledCard>
          <StyledCardHeader 
            title={
              <FormSectionTitle>
                <AccountIcon />
                Supplier Information
              </FormSectionTitle>
            }
          />
          <CardContent>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <Autocomplete
                  options={suppliers}
                  getOptionLabel={(option) => option.Name || option.name || ''}
                  isOptionEqualToValue={(option, value) => {
                    if (!option || !value) return false;
                    const optionId = option.Supplier_ID || option.supplier_id || option.id;
                    const valueId = value.Supplier_ID || value.supplier_id || value.id;
                    return optionId === valueId;
                  }}
                  value={purchaseOrder.supplier}
                  onChange={handleSupplierChange}
                  renderInput={(params) => (
                    <StyledFormField
                      {...params}
                      label="Supplier *"
                      variant="outlined"
                      error={error && error.includes('supplier')}
                      helperText={error && error.includes('supplier') ? error : ''}
                      fullWidth
                    />
                  )}
                  renderOption={(props, option) => (
                    <li {...props}>
                      <Box sx={{ display: 'flex', flexDirection: 'column' }}>
                        <Typography variant="body1">{option.Name || option.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          {option.Email || option.email || 'No email'} | {option.Phone_Number || option.phone || 'No phone'}
                        </Typography>
                      </Box>
                    </li>
                  )}
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <LocalizationProvider dateAdapter={AdapterDateFns}>
                  <DatePicker
                    label="Order Date"
                    value={purchaseOrder.orderDate ? new Date(purchaseOrder.orderDate) : null}
                    onChange={(date) => handleDateChange(date, 'orderDate')}
                    slotProps={{
                      textField: {
                        fullWidth: true,
                        variant: "outlined",
                        error: error && error.includes('order date'),
                        helperText: error && error.includes('order date') ? error : ''
                      }
                    }}
                  />
                </LocalizationProvider>
              </Grid>
              
              <Grid item xs={12} md={6}>
                <LocalizationProvider dateAdapter={AdapterDateFns}>
                  <DatePicker
                    label="Expected Delivery Date"
                    value={purchaseOrder.expectedDeliveryDate ? new Date(purchaseOrder.expectedDeliveryDate) : null}
                    onChange={(date) => handleDateChange(date, 'expectedDeliveryDate')}
                    slotProps={{
                      textField: {
                        fullWidth: true,
                        variant: "outlined",
                        error: error && error.includes('delivery date'),
                        helperText: error && error.includes('delivery date') ? error : ''
                      }
                    }}
                  />
                </LocalizationProvider>
              </Grid>
            </Grid>
          </CardContent>
        </StyledCard>
      )
    }
  ];

  return (
    <>
      <Box sx={{ padding: 3, maxWidth: 1200, margin: '0 auto' }}>
        {/* Breadcrumb navigation */}
        <Breadcrumbs sx={{ mb: 2 }}>
          <MuiLink component={Link} to="/" underline="hover" sx={{ display: 'flex', alignItems: 'center' }}>
            <HomeIcon sx={{ mr: 0.5 }} fontSize="inherit" />
            Dashboard
          </MuiLink>
          <MuiLink component={Link} to="/owner/inventory" state={{ role: userRole }} underline="hover">
            <InventoryIcon sx={{ mr: 0.5 }} fontSize="inherit" />
            Inventory
          </MuiLink>
          <MuiLink component={Link} to="/owner/inventory/purchase-orders" state={{ role: userRole }} underline="hover">
            <ShippingIcon sx={{ mr: 0.5 }} fontSize="inherit" />
            Purchase Orders
          </MuiLink>
          <Typography color="text.primary">
            {isEditMode ? 'Edit Purchase Order' : 'Create Purchase Order'}
          </Typography>
        </Breadcrumbs>
        
        {/* Page Header */}
        <PageHeader>
          <Typography variant="h4" component="h1" sx={{ fontWeight: 500, color: 'primary.main' }}>
            {isEditMode ? `Edit Purchase Order #${purchaseOrder.poNumber}` : 'Create New Purchase Order'}
          </Typography>
          <Box sx={{ display: 'flex', gap: 2 }}>
            <Button
              component={Link}
              to="/owner/inventory/purchase-orders"
              state={{ role: userRole }}
              startIcon={<ArrowBackIcon />}
              variant="outlined"
              sx={{ borderRadius: '8px' }}
            >
              Back to List
            </Button>
            {isEditMode && purchaseOrder.status !== 'draft' && (
              <Button
                startIcon={<EmailIcon />}
                variant="outlined"
                color="primary"
                onClick={handleOpenEmailDialog}
                sx={{ borderRadius: '8px' }}
              >
                Send Email
              </Button>
            )}
          </Box>
        </PageHeader>
        
        {/* Error Alert */}
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}
        
        {/* Stepper */}
        <Stepper activeStep={activeStep} orientation="horizontal" sx={{ mb: 4 }}>
          {steps.map((step, index) => (
            <Step key={step.label}>
              <StepLabel>{step.label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        
        {/* Current Step Content */}
        {steps[activeStep].content}
        
        {/* Navigation Buttons */}
        <ActionButtons>
          <Button
            disabled={activeStep === 0}
            onClick={handleBack}
            sx={{ mr: 1 }}
          >
            Back
          </Button>
          <Box sx={{ flex: '1 1 auto' }} />
          {activeStep < steps.length - 1 ? (
            <Button 
              variant="contained" 
              onClick={handleNext}
              sx={{ 
                borderRadius: '8px',
                px: 3
              }}
            >
              Continue
            </Button>
          ) : (
            <Box sx={{ display: 'flex', gap: 2 }}>
              <Button
                variant="outlined"
                color="primary"
                onClick={() => handlePreview()}
                startIcon={<SaveIcon />}
                disabled={loading}
                sx={{ borderRadius: '8px' }}
              >
                Preview
              </Button>
              <Button
                variant="contained"
                color="primary"
                onClick={() => handleSave('draft')}
                startIcon={loading ? <CircularProgress size={24} /> : <SaveIcon />}
                disabled={loading}
                sx={{ 
                  borderRadius: '8px',
                  px: 3
                }}
              >
                {loading ? 'Saving...' : 'Save as Draft'}
              </Button>
            </Box>
          )}
        </ActionButtons>
        
        {/* Email Dialog */}
        <Dialog
          open={emailDialogOpen}
          onClose={handleCloseEmailDialog}
          fullWidth
          maxWidth="sm"
        >
          <DialogTitle>Send Purchase Order Email</DialogTitle>
          <DialogContent>
            <Box sx={{ mt: 2 }}>
              <TextField
                label="Recipient Email"
                type="email"
                fullWidth
                value={recipientEmail}
                onChange={(e) => setRecipientEmail(e.target.value)}
                margin="normal"
                required
                error={!recipientEmail}
                helperText={!recipientEmail ? "Email is required" : ""}
              />
              <TextField
                label="Subject"
                fullWidth
                value={`Purchase Order #${purchaseOrder.poNumber}`}
                margin="normal"
                InputProps={{
                  readOnly: true,
                }}
              />
              <TextField
                label="Message"
                fullWidth
                multiline
                rows={4}
                defaultValue={`Please find attached purchase order #${purchaseOrder.poNumber}. Let us know if you have any questions.`}
                margin="normal"
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseEmailDialog} color="primary">
              Cancel
            </Button>
            <Button
              onClick={handleSendEmail}
              color="primary"
              variant="contained"
              disabled={emailLoading || !recipientEmail}
              startIcon={emailLoading ? <CircularProgress size={20} /> : <EmailIcon />}
            >
              {emailLoading ? 'Sending...' : 'Send Email'}
            </Button>
          </DialogActions>
        </Dialog>
        
        {/* Preview Dialog */}
        <Dialog
          open={previewDialogOpen}
          onClose={handleClosePreview}
          fullWidth
          maxWidth="md"
        >
          <DialogTitle>
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
              <Typography variant="h5">Purchase Order Preview</Typography>
              <Chip 
                label={previewData?.status?.toUpperCase() || 'DRAFT'} 
                color={previewData?.status === 'confirmed' ? 'success' : 'primary'}
                sx={{ fontWeight: 'bold' }}
              />
            </Box>
          </DialogTitle>
          <DialogContent>
            {previewData && (
              <>
                <Paper sx={{ p: 2, mb: 3, borderRadius: '8px' }}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="subtitle1" fontWeight="bold">PO Number:</Typography>
                      <Typography variant="body1">{previewData.poNumber}</Typography>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="subtitle1" fontWeight="bold">Date:</Typography>
                      <Typography variant="body1">{new Date(previewData.orderDate).toLocaleDateString()}</Typography>
                    </Grid>
                    {previewData.expectedDeliveryDate && (
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle1" fontWeight="bold">Expected Delivery:</Typography>
                        <Typography variant="body1">{new Date(previewData.expectedDeliveryDate).toLocaleDateString()}</Typography>
                      </Grid>
                    )}
                    <Grid item xs={12} md={6}>
                      <Typography variant="subtitle1" fontWeight="bold">Created:</Typography>
                      <Typography variant="body1">{new Date(previewData.createdAt).toLocaleString()}</Typography>
                    </Grid>
                  </Grid>
                </Paper>
                
                <Typography variant="h6" gutterBottom>Supplier Information</Typography>
                <Paper sx={{ p: 2, mb: 3, borderRadius: '8px' }}>
                  {previewData.supplier ? (
                    <Grid container spacing={2}>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle1" fontWeight="bold">Supplier:</Typography>
                        <Typography variant="body1">{previewData.supplier.Name || previewData.supplier.name}</Typography>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle1" fontWeight="bold">Contact:</Typography>
                        <Typography variant="body1">{previewData.supplier.Contact_Person || previewData.supplier.contactPerson || '-'}</Typography>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle1" fontWeight="bold">Email:</Typography>
                        <Typography variant="body1">{previewData.supplier.Email || previewData.supplier.email || '-'}</Typography>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Typography variant="subtitle1" fontWeight="bold">Phone:</Typography>
                        <Typography variant="body1">{previewData.supplier.Phone_Number || previewData.supplier.phone || '-'}</Typography>
                      </Grid>
                    </Grid>
                  ) : (
                    <Typography variant="body1">No supplier information</Typography>
                  )}
                </Paper>
                
                <Typography variant="h6" gutterBottom>Order Items</Typography>
                <TableContainer component={Paper} sx={{ mb: 3, borderRadius: '8px' }}>
                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>Product</TableCell>
                        <TableCell>SKU</TableCell>
                        <TableCell align="right">Quantity</TableCell>
                        <TableCell align="right">Unit Price</TableCell>
                        <TableCell align="right">Total</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {previewData.items.length > 0 ? (
                        previewData.items.map((item, index) => (
                          <TableRow key={index}>
                            <TableCell>{item.productName}</TableCell>
                            <TableCell>{item.sku || '-'}</TableCell>
                            <TableCell align="right">{item.quantity}</TableCell>
                            <TableCell align="right">${parseFloat(item.unitPrice || 0).toFixed(2)}</TableCell>
                            <TableCell align="right">${parseFloat(item.total || 0).toFixed(2)}</TableCell>
                          </TableRow>
                        ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={5} align="center">No items</TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </TableContainer>
                
                <Paper sx={{ p: 2, mb: 3, borderRadius: '8px', backgroundColor: '#f9fafc' }}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} md={6}>
                      {previewData.notes && (
                        <>
                          <Typography variant="subtitle1" fontWeight="bold">Notes:</Typography>
                          <Typography variant="body2">{previewData.notes}</Typography>
                        </>
                      )}
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', maxWidth: 300, mb: 1 }}>
                          <Typography variant="body1">Subtotal:</Typography>
                          <Typography variant="body1">${parseFloat(previewData.subtotal || 0).toFixed(2)}</Typography>
                        </Box>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', maxWidth: 300, mb: 1 }}>
                          <Typography variant="body1">Tax ({previewData.taxRate}%):</Typography>
                          <Typography variant="body1">${parseFloat(previewData.taxAmount || 0).toFixed(2)}</Typography>
                        </Box>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', maxWidth: 300, mb: 1 }}>
                          <Typography variant="body1">Shipping:</Typography>
                          <Typography variant="body1">${parseFloat(previewData.shippingCost || 0).toFixed(2)}</Typography>
                        </Box>
                        <Divider sx={{ width: '100%', maxWidth: 300, my: 1 }} />
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', width: '100%', maxWidth: 300 }}>
                          <Typography variant="h6">Total:</Typography>
                          <Typography variant="h6" color="primary">${parseFloat(previewData.totalAmount || 0).toFixed(2)}</Typography>
                        </Box>
                      </Box>
                    </Grid>
                  </Grid>
                </Paper>
              </>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={handleClosePreview} color="primary">
              Close
            </Button>
            <Button
              onClick={() => handleSave('pending')}
              color="primary"
              variant="contained"
              disabled={loading}
              startIcon={loading ? <CircularProgress size={20} /> : <ShareIcon />}
            >
              {loading ? 'Saving...' : 'Finalize Order'}
            </Button>
          </DialogActions>
        </Dialog>
        
        {/* Snackbar Alert */}
        <Snackbar
          open={snackbar.open}
          autoHideDuration={6000}
          onClose={() => setSnackbar({ ...snackbar, open: false })}
        >
          <Alert 
            onClose={() => setSnackbar({ ...snackbar, open: false })} 
            severity={snackbar.severity}
            variant="filled"
            sx={{ width: '100%' }}
          >
            {snackbar.message}
          </Alert>
        </Snackbar>
      </Box>
    </>
  );
};

export default CreatePurchaseOrder; 